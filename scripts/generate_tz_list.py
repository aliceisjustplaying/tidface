# Requires Python 3.9+ for zoneinfo
import zoneinfo
from datetime import datetime
from os import path
# Use shared DST tools
from tz_common import find_dst_transitions as find_dst_transitions_accurate

def generate_tz_list_c_code():
    """Generates C code for a static timezone list with DST transition timestamps."""

    target_year = datetime.now().year # Use current year for transitions
    print(f"Finding DST transitions for year {target_year}...")

    available_zones = zoneinfo.available_timezones()
    print(f"Found {len(available_zones)} available timezones.")

    processed_zones = {} # Key: TUPLE(std_offset_s, dst_offset_s, start_utc, end_utc), Value: Dict of zone data

    for tz_name in available_zones:
        # Basic filtering (no dead code here)
        if tz_name.startswith("Etc/") or "/" not in tz_name: continue
        if tz_name in ["Factory", "factory"] or tz_name.lower().startswith("right/") or tz_name.lower().startswith("posix/"): continue

        std_offset_s, dst_offset_s, start_utc, end_utc = find_dst_transitions_accurate(tz_name, target_year)
        city_name = tz_name.split('/')[-1].replace('_', ' ')

        # --- Filter out generic names ---
        # Comprehensive list based on review of tz_list.c
        generic_names_to_exclude = {
            "Samoa", "Hawaii", "Aleutian", "Alaska", "Pacific", "Arizona", "Yukon",
            "Mountain", "General", "Saskatchewan", "Central", "Knox IN", "EasterIsland",
            "Acre", "Jamaica", "Michigan", "Eastern", "East-Indiana", "Atlantic",
            "Continental", "Newfoundland", "East", "Bahia", "Noronha", "South Georgia",
            "Canary", "Faeroe", "Faroe", "Guernsey", "Isle of Man", "Jersey",
            "Madeira", "Jan Mayen", "West", "North", "South", "ACT", "NSW",
            "Tasmania", "Victoria", "Queensland", "Yap", "South Pole", "Kanton",
            # Add or remove names as needed
        }
        # Case-insensitive check for exclusion
        if city_name.lower() in {name.lower() for name in generic_names_to_exclude}:
            continue # Skip this generic name

        # Convert offsets back to hours for potential display, but keep seconds for key
        std_offset_h = std_offset_s / 3600.0
        dst_offset_h = dst_offset_s / 3600.0

        # Group by the unique combination of std offset, dst offset, and transitions
        key_tuple = (std_offset_s, dst_offset_s, start_utc, end_utc)
        if city_name and city_name[0].isupper():
            if key_tuple not in processed_zones:
                 processed_zones[key_tuple] = {
                    "std_offset_s": std_offset_s, # Store seconds internally
                    "dst_offset_s": dst_offset_s,
                    "start_utc": start_utc,
                    "end_utc": end_utc,
                    "names": []
                 }
            # Add city name if not already present
            if city_name not in processed_zones[key_tuple]["names"]:
                processed_zones[key_tuple]["names"].append(city_name)

    # Convert dict values to a list and sort by std offset, then DST offset, then by DST start/end to keep consistent ordering
    tz_data_list = sorted(
        processed_zones.values(),
        key=lambda x: (
            x["std_offset_s"],
            x["dst_offset_s"],
            x["start_utc"],
            x["end_utc"]
        )
    )
    print(f"Generated data for {len(tz_data_list)} unique offset/DST rule combinations.")

    # --- C Code Generation: Flatten name pool and tz_list entries ---
    # Build a flat pool of city names and compute offsets
    names_pool = []
    for zone in tz_data_list:
        sorted_names = sorted(zone['names'])
        zone['name_offset'] = len(names_pool)
        zone['name_count'] = len(sorted_names)
        names_pool.extend(sorted_names)

    # Begin C output
    c_code = "// Generated by Python script using zoneinfo\n"
    c_code += f"// Contains Standard & DST offsets for {target_year}.\n"
    c_code += "// WARNING: DST rules accurate only for the generated year.\n\n"
    c_code += "#include <stdint.h>\n\n"

    # Flattened list of all city names
    c_code += "static const char* tz_name_pool[] = {\n"
    for name in names_pool:
        c_code += f"    \"{name}\",\n"
    c_code += "};\n\n"

    # TzInfo struct with name pool indices
    c_code += "typedef struct {\n"
    c_code += "    float std_offset_hours;\n"
    c_code += "    float dst_offset_hours;\n"
    c_code += "    int64_t dst_start_utc;\n"
    c_code += "    int64_t dst_end_utc;\n"
    c_code += "    int name_offset;\n"
    c_code += "    int name_count;\n"
    c_code += "} TzInfo;\n\n"

    # Main tz_list entries
    c_code += "static const TzInfo tz_list[] = {\n"
    for zone in tz_data_list:
        std_h = zone['std_offset_s'] / 3600.0
        dst_h = zone['dst_offset_s'] / 3600.0
        start = zone['start_utc']
        end = zone['end_utc']
        offs = zone['name_offset']
        cnt = zone['name_count']
        c_code += f"    {{ {std_h:.2f}f, {dst_h:.2f}f, {start}LL, {end}LL, {offs}, {cnt} }},\n"
    c_code += "};\n\n"
    c_code += f"#define TZ_LIST_COUNT (sizeof(tz_list)/sizeof(tz_list[0]))\n"
    c_code += f"#define TZ_NAME_POOL_COUNT (sizeof(tz_name_pool)/sizeof(tz_name_pool[0]))\n"
    return c_code

# --- Main execution ---
if __name__ == "__main__":
    c_code_output = generate_tz_list_c_code()
    output_filename = path.join(path.dirname(__file__), "../src/c/tz_list.c")  # Default output path
    try:
        with open(output_filename, "w") as f:
            f.write(c_code_output)
        print(f"\nSuccessfully written timezone data (with accurate DST timestamps) to {output_filename}")
    except IOError as e:
        print(f"\nError: Could not write to file {output_filename}: {e}")
