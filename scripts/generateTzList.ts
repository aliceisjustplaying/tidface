import { DateTime } from 'luxon';
import { rawTimeZones } from '@vvo/tzdb';
import * as fs from 'fs/promises';
import * as path from 'path';
import { program } from 'commander';
import { findDstTransitions } from './tzCommon';

interface TzBucket {
  std: number;
  dst: number;
  start: number;
  end: number;
  names: Set<string>;
  nameOffset?: number;
  nameCount?: number;
}

function getCityName(tz: string): string {
  const part = tz.split('/').pop() || tz;
  return part.replace(/_/g, ' ');
}

export async function generateTzCCode(outPath: string): Promise<void> {
  const year = DateTime.utc().year;
  console.log(`Generating tz_list for year ${year}`);

  const buckets = new Map<string, TzBucket>();

  rawTimeZones.forEach(({ name }) => {
    if (!name.includes('/')) return;
    if (name.startsWith('Etc/')) return;
    if (/^(Factory|factory)/.test(name)) return;
    if (/^(right|posix)\//i.test(name)) return;

    const [std, dst, start, end] = findDstTransitions(name, year);
    const city = getCityName(name);
    if (!/^[A-Z]/.test(city)) return;

    const key = `${std}_${dst}_${start}_${end}`;
    let bucket = buckets.get(key);
    if (!bucket) {
      bucket = { std, dst, start, end, names: new Set() };
      buckets.set(key, bucket);
    }
    bucket.names.add(city);
  });

  const ordered = Array.from(buckets.values()).sort((a,b)=>{
    if(a.std!==b.std) return a.std-b.std;
    if(a.dst!==b.dst) return a.dst-b.dst;
    if(a.start!==b.start) return a.start-b.start;
    return a.end-b.end;
  });

  // Build flat name pool
  const namePool: string[] = [];
  ordered.forEach(b=>{
    const names = Array.from(b.names).sort();
    b.nameOffset = namePool.length;
    b.nameCount = names.length;
    namePool.push(...names);
  });

  // Emit C code
  let c = '';
  c += '// Auto-generated by generateTzList.ts\n';
  c += `// Year ${year} DST data (Luxon / IANA)\n\n`;
  c += '#include <stdint.h>\n\n';

  c += 'static const char* tz_name_pool[] = {\n';
  namePool.forEach(n=>{ c += `    "${n}",\n`; });
  c += '};\n\n';

  c += 'typedef struct {\n';
  c += '    float std_offset_hours;\n';
  c += '    float dst_offset_hours;\n';
  c += '    int64_t dst_start_utc;\n';
  c += '    int64_t dst_end_utc;\n';
  c += '    int name_offset;\n';
  c += '    int name_count;\n';
  c += '} TzInfo;\n\n';

  c += 'static const TzInfo tz_list[] = {\n';
  ordered.forEach(b=>{
    c += `    { ${(b.std/3600).toFixed(2)}f, ${(b.dst/3600).toFixed(2)}f, ${b.start}LL, ${b.end}LL, ${b.nameOffset}, ${b.nameCount} },\n`;
  });
  c += '};\n\n';
  c += `#define TZ_LIST_COUNT (sizeof(tz_list)/sizeof(tz_list[0]))\n`;
  c += `#define TZ_NAME_POOL_COUNT (sizeof(tz_name_pool)/sizeof(tz_name_pool[0]))\n`;

  await fs.writeFile(outPath, c, 'utf-8');
  console.log(`Wrote ${ordered.length} buckets and ${namePool.length} names to ${outPath}`);
}

// CLI
if (require.main === module) {
  program
    .option('--out <path>', 'C output file', path.join(__dirname,'../src/c/tz_list.c'))
    .parse(process.argv);
  const { out } = program.opts();
  generateTzCCode(out).catch(err=>{ console.error(err); process.exit(1); });
} 
